import sys
import os
import img2pdf
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QAction, QFileDialog, QMessageBox, 
    QGraphicsView, QGraphicsScene, QToolBar, QVBoxLayout, QWidget
)
from PyQt5.QtGui import QPixmap, QPen, QColor, QPainter, QImage
from PyQt5.QtCore import Qt, QRectF, QPointF, pyqtSignal
from PyQt5.QtWidgets import QGraphicsObject
from PIL import Image
from PIL.ImageQt import ImageQt

# Increase limit to prevent DecompressionBombWarning in PIL
Image.MAX_IMAGE_PIXELS = 200000000

# --- DraggableLineItem 변경 --- #
class DraggableLineItem(QGraphicsObject):
    # signal: 라인 이동이 완료되었음을 알림 (특히 primary 라인의 경우)
    lineMoved = pyqtSignal()

    def __init__(self, scene_width, y_pos=0, isPrimary=False, autoGenerated=False):
        super().__init__()
        self._sceneWidth = scene_width
        self._lineHeight = 3  # 두께
        self._color = QColor("red")
        self.setFlags(
            QGraphicsObject.ItemIsMovable | 
            QGraphicsObject.ItemIsSelectable
        )
        self.setPos(0, y_pos)
        # 플래그 추가
        self.isPrimary = isPrimary      # 첫 번째 자동 생성 라인 여부
        self.autoGenerated = autoGenerated  # 자동 생성된 라인인지 여부

    def boundingRect(self):
        return QRectF(0, -self._lineHeight/2, self._sceneWidth, self._lineHeight)

    def paint(self, painter, option, widget):
        pen = QPen(self._color, self._lineHeight)
        painter.setPen(pen)
        painter.drawLine(0, 0, self._sceneWidth, 0)

    def itemChange(self, change, value):
        if change == QGraphicsObject.ItemPositionHasChanged:
            # x 좌표 고정, y 좌표만 업데이트
            new_pos = value.toPointF()
            return QPointF(0, new_pos.y())
        return super().itemChange(change, value)

    def mouseReleaseEvent(self, event):
        super().mouseReleaseEvent(event)
        # primary 라인이 이동 완료되면 signal emit
        if self.isPrimary:
            self.lineMoved.emit()


# --- GraphicsView 그대로 --- #
class GraphicsView(QGraphicsView):
    def __init__(self, scene, parent=None):
        super().__init__(scene, parent)
        

# --- MainWindow 변경 --- #
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Split PNG to A3-Padded PDF (with auto lines + merge images)")

        # Toolbar Actions
        openAction = QAction("Open", self)
        openAction.triggered.connect(self.openImage)

        addLineAction = QAction("Add Line", self)
        addLineAction.triggered.connect(self.addLineAtViewCenter)

        exportAction = QAction("Save PDF", self)
        exportAction.triggered.connect(self.exportPdf)

        # Toolbar
        toolbar = QToolBar("Main Toolbar")
        toolbar.addAction(openAction)
        toolbar.addAction(addLineAction)
        toolbar.addAction(exportAction)
        self.addToolBar(toolbar)

        # Scene & View
        self.scene = QGraphicsScene(self)
        self.view = GraphicsView(self.scene, self)
        self.view.setRenderHint(QPainter.Antialiasing)

        # Layout
        central_widget = QWidget(self)
        layout = QVBoxLayout(central_widget)
        layout.addWidget(self.view)
        self.setCentralWidget(central_widget)

        # Image info
        self.originalPixmap = None   # QPixmap for display
        self.mergedImage = None      # PIL Image (병합 이미지가 있을 경우)
        self.currentImgPath = None   # 단일 파일일 경우 사용
        self.imageWidth = 0
        self.imageHeight = 0

        # Store lines: 모든 라인 (자동/수동)
        self.draggableLines = []
        # 별도로 자동 생성된 라인을 추적 (초기 auto라인은 여기에 저장)
        self.autoLines = []

    def openImage(self):
        """
        여러 이미지 선택 가능 (여러 개면 세로로 merge).
        이후 A3 비율에 맞게 자동 라인 생성.
        """
        # 여러 파일 선택: getOpenFileNames 사용
        fileNames, _ = QFileDialog.getOpenFileNames(
            self, "Open PNG/JPEG images", "", "Images (*.png *.jpg *.jpeg *.bmp *.gif)"
        )
        if not fileNames:
            return

        # clear previous scene and lines
        self.scene.clear()
        self.draggableLines.clear()
        self.autoLines.clear()
        self.mergedImage = None
        self.currentImgPath = None

        if len(fileNames) == 1:
            # 단일 파일일 경우
            fileName = fileNames[0]
            pixmap = QPixmap(fileName)
            if pixmap.isNull():
                QMessageBox.warning(self, "Error", "Cannot load the selected image.")
                return
            self.currentImgPath = fileName
            self.originalPixmap = pixmap
            # PIL 이미지도 열어두기 (exportPdf에서 사용)
            pil_image = Image.open(fileName)
            self.imageWidth, self.imageHeight = pil_image.size
        else:
            # 여러 파일 -> PIL 이미지로 열어서 width 동일 여부 확인
            images = []
            common_width = None
            total_height = 0
            try:
                for fn in fileNames:
                    im = Image.open(fn)
                    if common_width is None:
                        common_width = im.width
                    elif im.width != common_width:
                        QMessageBox.critical(self, "Error", "Selected images do not have the same width.")
                        return
                    images.append(im)
                    total_height += im.height
            except Exception as e:
                QMessageBox.critical(self, "Error", f"An error occurred while loading images:\n{e}")
                return
            # 병합 이미지 생성
            merged = Image.new("RGB", (common_width, total_height), (255, 255, 255))
            y_offset = 0
            for im in images:
                merged.paste(im, (0, y_offset))
                y_offset += im.height
            self.mergedImage = merged
            self.imageWidth, self.imageHeight = merged.size
            # QPixmap 으로 변환 (PIL 이미지 -> QImage -> QPixmap)
            qimage = ImageQt(merged)
            self.originalPixmap = QPixmap.fromImage(qimage)

        # Add image to scene
        self.pixmapItem = self.scene.addPixmap(self.originalPixmap)
        self.scene.setSceneRect(self.pixmapItem.boundingRect())

        # --- Auto-generate lines based on A3 ratio --- #
        # A3 ratio: height/width = 297/420 => ideal height = imageWidth / (297/420)
        a3_ratio = 297 / 420
        ideal_chunk = self.imageWidth / a3_ratio
        current_pos = ideal_chunk

        # 최초 자동 생성 라인: primary line
        if current_pos < self.imageHeight:
            primary_line = DraggableLineItem(self.imageWidth, current_pos, isPrimary=True, autoGenerated=True)
            primary_line.lineMoved.connect(self.onPrimaryLineMoved)
            self.scene.addItem(primary_line)
            self.draggableLines.append(primary_line)
            self.autoLines.append(primary_line)
        else:
            primary_line = None

        # 나머지 자동 생성 라인들
        while current_pos < self.imageHeight:
            current_pos += ideal_chunk
            if current_pos >= self.imageHeight:
                break
            line_item = DraggableLineItem(self.imageWidth, current_pos, isPrimary=False, autoGenerated=True)
            self.scene.addItem(line_item)
            self.draggableLines.append(line_item)
            self.autoLines.append(line_item)

    def addLineAtViewCenter(self):
        """
        추가로 수동 라인을 추가 (이 경우 autoGenerated=False)
        """
        if (not self.currentImgPath and self.mergedImage is None) or self.originalPixmap is None:
            QMessageBox.warning(self, "Error", "Open an image first.")
            return

        center_in_view = self.view.viewport().rect().center()
        center_in_scene = self.view.mapToScene(center_in_view)
        y_pos = center_in_scene.y()
        # Clamp
        y_pos = max(0, min(y_pos, self.imageHeight))
        line_item = DraggableLineItem(self.imageWidth, y_pos, isPrimary=False, autoGenerated=False)
        self.scene.addItem(line_item)
        self.draggableLines.append(line_item)

    def onPrimaryLineMoved(self):
        """
        슬롯: 첫 번째(Primary) 자동 생성 라인이 이동 완료되었을 때,
        나머지 자동 생성 라인(자동으로 생성된 라인)을 제거하고
        A3 비율에 맞게 새로 생성합니다.
        """
        # primary_line 찾기
        primary_line = None
        for line in self.autoLines:
            if getattr(line, "isPrimary", False):
                primary_line = line
                break
        if primary_line is None:
            return

        # 제거: autoLines 중 primary가 아닌 것들
        for line in self.autoLines[:]:
            if not line.isPrimary:
                self.scene.removeItem(line)
                self.draggableLines.remove(line)
                self.autoLines.remove(line)

        # A3 ratio 기반 고정 chunk: (이미지 width 기준)
        a3_ratio = 297 / 420
        ideal_chunk = self.imageWidth / a3_ratio
        # 첫 라인의 위치는 사용자가 조정한 값
        base_y = primary_line.pos().y()
        current_pos = base_y

        # 새 자동 라인 생성: base_y + ideal_chunk, base_y + 2*ideal_chunk, ... 
        while True:
            current_pos += ideal_chunk
            if current_pos >= self.imageHeight:
                break
            new_line = DraggableLineItem(self.imageWidth, current_pos, isPrimary=False, autoGenerated=True)
            self.scene.addItem(new_line)
            self.draggableLines.append(new_line)
            self.autoLines.append(new_line)

    def exportPdf(self):
        """
        1) 라인 위치에 따라 이미지 조각들을 crop
        2) 각 조각을 하단만 A3 비율에 맞게 패딩
        3) PDF로 export
        """
        if (not self.currentImgPath and self.mergedImage is None) or self.originalPixmap is None:
            QMessageBox.warning(self, "Error", "Please open an image first.")
            return

        outPdfPath, _ = QFileDialog.getSaveFileName(
            self, "Save as PDF", "", "PDF Files (*.pdf)"
        )
        if not outPdfPath:
            return

        # PIL 이미지 로딩: 단일 파일인 경우 파일에서, 병합 이미지인 경우 self.mergedImage 사용
        if self.mergedImage is not None:
            original_image = self.mergedImage
        else:
            try:
                original_image = Image.open(self.currentImgPath)
            except Exception as e:
                QMessageBox.critical(self, "Error", f"An error occurred while loading image:\n{e}")
                return
        width, height = original_image.size

        # 라인 위치 수집 (0과 image bottom 포함)
        line_y_positions = []
        for lineItem in self.draggableLines:
            y_val = lineItem.pos().y()
            if 0 < y_val < height:
                line_y_positions.append(y_val)
        line_y_positions.sort()
        cut_positions = [0] + line_y_positions + [height]

        # 이미지 조각 crop
        split_images = []
        for i in range(len(cut_positions)-1):
            top = int(cut_positions[i])
            bottom = int(cut_positions[i+1])
            if bottom <= top:
                continue
            cropped = original_image.crop((0, top, width, bottom))
            split_images.append(cropped)
        if not split_images:
            split_images = [original_image]

        # A3 ratio: 297/420
        a3_ratio = 297 / 420

        def pad_bottom_to_a3(img):
            """
            주어진 이미지의 width를 유지하며, 높이가 A3 비율(이미지 width 기준 ideal height)보다 작으면
            아래쪽을 흰색으로 채워 A3 비율로 만듭니다.
            """
            w, h = img.size
            ideal_h = int(w / a3_ratio)
            if h >= ideal_h:
                # 이미지가 ideal_h 이상이면 그대로 사용
                return img
            canvas = Image.new("RGB", (w, ideal_h), (255, 255, 255))
            canvas.paste(img, (0,0))
            return canvas

        padded_images = [pad_bottom_to_a3(im) for im in split_images]

        temp_file_list = []
        try:
            for idx, p_img in enumerate(padded_images):
                temp_path = f"__temp_export_{idx}.png"
                p_img.save(temp_path, "PNG")
                temp_file_list.append(temp_path)
            with open(outPdfPath, "wb") as f:
                f.write(img2pdf.convert(temp_file_list))
            QMessageBox.information(self, "Done", f"PDF has been saved to:\n{outPdfPath}")
        except Exception as e:
            QMessageBox.critical(self, "Error", f"An error occurred while exporting PDF:\n{e}")
        finally:
            for temp_path in temp_file_list:
                if os.path.exists(temp_path):
                    os.remove(temp_path)

def main():
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
